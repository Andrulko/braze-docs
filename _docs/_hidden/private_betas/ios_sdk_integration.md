---
nav_title: iOS SDK Integration
permalink: "/ios_sdk/"
hidden: true
---

# Braze iOS SDK Integration Guide

> Initial setup from your app group in the Braze dashboard to integrate the Braze iOS SDK and its core components into your application

## Setup Podfile and info.plist file

### Step 1: Obtain API Key and SDK Endpoint
1. Login to your existing app group in the Braze dashboard.
2. Create a new app for your iOS platform. (Manage Settings -> Settings -> + Add App)<br> Your API key and SDk endpoint will be autogenerated for you.

### Step 2: Setup your Podfile
1. Naviagate to your podfile in your Xcode project.
2. Add the following line to your podfile:
```swift
pod 'Appboy-iOS-SDK'
```
This will install the latest version of the Braze iOS SDK. Save the changes in your Podfile, and then run:
```swift
pod install/update
```

### Step 3: Configure info.plist file 
1. Navigate to your info.plist in your Xcode project.
2. Add a new entry named _Appboy_ that is of type dictionary, and within that entry, create two sub-entries in your dictionary. 
  - Create an entry named _Endpoint_ that is of type String.
  - Create an entry named _LogLevel_ that is of type String.
3. Copy the endpoint found within the __Settings__ page in the dashboard and paste the value as the _Endpoint_ value in the _Appboy_ dictionary
4. For the _LogLevel_ entry, set the value to "0". This enables verbose logging that prints pertinent information to the Xcode debugger console.

### Checkpoint #1
Proceed to compile your code and run your application. 

Now that you have begun the basic setup of the Braze iOS SDK, the next step is to create a _BrazeManager.swift_ helper file to host the iOS code related to the Braze iOS SDK.

## BrazeManager.swift

### Create BrazeManager.swift

> The _BrazeManager.swift_ file demonstrates how to decouple any dependencies on the Braze iOS SDK from the rest of your production code. The objective is to have only one import Appboy-iOS-SDK in your entire application.

All of the Braze-related dependencies are handled in the _BrazeManager.swift_ file that your existing production code calls into. 

Import statements will be referred to as _import Appboy-iOS-SDK_.

1. Create a new Swift file to be added to your project at your desired location and name the file BrazeManager. (Xcode -> New -> File)
2. Replace `import Foundation` with `import Appboy-iOS-SDK`
3. Create the _BrazeManager_ class that will be used to host all Braze-related methods and variables. _BrazeManager_ is an _NSObject_ class and not a struct, so it can conform to ABK delegates such as the _ABKInAppMessageUIDelegate_.

{% tabs %}
{% tab BrazeManager Object %}
The _BrazeManager_ object is a singleton by design to ensure that only one instance of this class will be used. It is done to provide a unified point of access to the object. 

```swift
class BrazeManager: NSObject {
  1//
  static let shared = BrazeManager()
  2//
  private let apikey = "YOUR-API-KEY"
  3//
  private var appboyOptions[String:Any]{
    return [:]
  }
}
```
1. Add a static variable named _shared_ that initializes the _BrazeManager_ class. This is guaranteed to be lazily initiated only once. <br><br>
2. Navigate back to your app group in the Braze dashboard, and copy the _API Key_ value. Next, add a private constant variable named _apiKey_ which will be used for your API Key. Replace "YOUR-API-KEY" with the value from your App Group in the Braze dashboard. The value must be a String object.<br><br>
3. Add a private computed variable named _appboyOptions_ which will be used to store configuration values for the SDK. It will be empty for now. The key must be a String object, and the value can be of any type.
{% endtab %}
{% endtabs %}

### Initialization

The SDK should be initialized on the main thread. 

{% tabs %}
{% tab BrazeManager.swift %}
```swift
1 //
func application(_ application: UIapplication, didFinishLaunchingWithOptions launchOptions:[UIApplication.LaunchOptionsKey:Any]?){
  2//
  Appboy.start(withAPIKey: apikey, in: applciation, withLaunchOptions: launchOptions, withAppboyOptions: appboyOptions)

}
```
1. Add the _didFinishLaunching..._ method from the _AppDelegate.swift_ file sans return value in your BrazeManger.swift file. By creating a similar method in the _BrazeManager.swift_ file, there will not be an _import Appboy-iOS-SDK_ statement in your _AppDelegate.swift_ file.<br><br>
2. Proceed to add the lines of code to initialize the SDK using your newly declared _apiKey_ and _appboyOptions_ variables

{% endtab %}
{% endtabs %}

Go back to the _AppDelegate.swift_

{% tabs %}
{% tab AppDelegate.swift %}
Add the following in the AppDelegate's _didFinishLaunching..._ method to handle the Appboy initialization from the _BrazeManager_ helper file.

There is no need to add an _import Appboy-iOS-SDK_ statement in the _AppDelegate.swift_.

```swift
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions:
[UIApplication.LaunchOptionsKey: Any]?) -> Bool {
  // Override point for customization after application launch

  BrazeManager.shared.application(application, didFinishLaunchingWithOptions: launchOptions)

  return true
```
{% endtab %}
{% endtabs %}

#### Checkpoint #2
Proceed to compile your code and run your application.

At this point, the SDK should be up and running. 

In your dashboard, observe that sessions are being logged before advancing any further.

### Push Notifications

#### Add Push Certificate

Go back to your existing app group in the Braze dashboard. Add your push certificate file to your Braze dashboard. 

#### Register for Push Notifications

Next, you must register for push notifications. This guide assumes you have set up your push credentials correctly in your Apple developer portal and Xcode project. 

The code for registering push notifications will be added in the _didFinishLaunching..._ method in the _BrazeManager.swift_ file. Your initialization code should currently look like this:

{% tabs %}
{% tab BrazeManager.swift %}

```swift
func application(_ application: UIapplication, didFinishLaunchingWithOptions launchOptions:[UIApplication.LaunchOptionsKey:Any]?){
  Appboy.start(withAPIKey: apikey, in: applciation, withLaunchOptions: launchOptions, withAppboyOptions: appboyOptions)
  1//
  let options: UNAuthorizationOptions = [.alert, . sound, .bagde]
  2//
  UNUserNotificationCenter.current().requestAuthorization(option: options){ (granted, error) in
  3//
    Appboy.sharedInstance()?.pushAuthorization(fromUserNotificationCenter: granted)
  }
  4// 
  UIApplications.shared.registerForRemoteNotificiations()
}
```
1. Add the following line to configure the contents for requesting authorization to interact with the user. These options are listed as an example.<br><br>
2. Now that options are listed, you must request for authorization to send your users push notifications. The user's response to allow or deny push notifications is tracked in the form of the _granted_ variable.<br><br>
3. Add the following line to forward the push authorization results to Braze after the user interacts with the notification prompt.<br><br>
4. Add the following to initiate the registration process with APNs. If the registration succeeds, the app calls your _AppDelegate's_ object's _didRegisterForRemoteNotificationsWithDeviceToken_ method. 

{% endtab %}
{% endtabs %}

#### Checkpoint #3

Proceed to compile your code and run your application.

- In your app, confirm that you are being prompted for push notifications before advancing any further.
- If you are not prompted, try deleting and re-installing the app to ensure the push notification prompt was not displayed previously.

#### Forward Push Notification Methods

The next step is to forward the system push notifications methods from _AppDelegate.swift_ to the _BrazeManager.swift_ to be handled by the Braze iOS SDK.

##### Step 1: Create Extension for Push Notificiation Code (Optional)

This step is optional, but creating an extension for your push notification code in your _BrazeManager.swift_ file reads in a more organized manner as to what purpose is being served in the helper file, like so:

{% tabs %}
{% tab BrazeManager.swift %}
```swift
// MARK - Push Notifications
extensions BrazeManager {
  1// 
  func application(_ application: UIApplication,
didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
  2 //
  Appboy.sharedInstance().?registerDeviceToken(deviceToken)
  }
}
```

1. Follow the pattern of not including an _import Appboy-iOS-SDK_ statement in your _AppDelegate_, we will handle the push notifications methods in the _BrazeManager.swift_. User's device tokens need to be passed to Braze from the _didRegisterForRemote..._ method. Add the same method from the _AppDelegate_ in your _BrazeManager_ class.<br><br>
2. In the method you added, add the following line inside the method to register the device token to Braze. This is necessary for Braze to associate the token with the current device. 

{% endtab %}
{% endtabs %}

##### Step 2: Support Remote Notifications
In the _Signing & Capabilities_ tab, add _Background Modes_ support and select _Remote notificiations_ to begin your support of remote notifications that originate from Braze.

##### Step 3: Remote Notification Handling
The Braze SDK can handle remote notifications that originate from Braze. Add the following method to your _BrazeManager.swift_ file in the push notification extension.

{% tabs %}
{% tab BrazeManager.swift %}
```swift
func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
  1//
  Appboy.sharedInstance()?.register(application, didReceiveRemoteNotification: userInfo, fetchCompletiionHandler: completionHandler)
}
```
1. In the method just added, add the following line inside the method to forward remote notifications to Braze. The SDK will automatically ignore push notifications that do not originate from Braze.
{% endtab %}
{% endtabs %}

##### Step 4: Forward Notification Responses

The Braze SDK can handle the response of push notifications that originate from Braze. Add the following method to your _BrazeManager.swift_ file.

{% tabs %}
{% tab BrazeManager.swift %}
```swift
func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void)
{
  1//
  Appboy.sharedInstance()?.userNotificationCenter(center, didReceive: response, withCompletionHandler: completionHandler)
}
```
1. In the method you just added, add the following line in the method to forward the response of the notifications to Braze. The SDK will automatically ignore responses from push notifications that do not originate from Braze.

{% endtab %}
{% endtabs %}

#### Checkpoint #4

Proceed to Compile your code and run your application. 

Try sending yourself a push notification from the Braze dashboard. 

In the dashboard, observe that analytics are being logged from push notifications before advancing any further. 

### Access ABKUser variables and Methods

The next step is to easily access the _ABKUser_ variables and methods. This step is optional, but creating an extension for your user code in your _Brazemanager.swift_ file reads in a more organized manner as to what purpose is being served in the helper file, like so:

{% tabs %}
{% tab BrazeManager.swift %}
```swift
// Mark: User
extension BrazeManager {
  // 1
  var user: ABKUser?{
    return Appboy.sharedInstance()?.user
  }
  //2 
  var userId: String?{
    return user?.userID
  }
  //3
  func changeUser(_userId: String){
    Appboy.sharedInstance()?.changeUser(userId)
  }
}
```

1. An ABKUser object represents a known or anonymous user in your iOS application. Add a computed variable to retrieve the _ABKUser_. This variable will be reused to retrieve variables about the user. The _ABKUser_ object itself is _&#95;Nonnull_, but the computed value is optional due to the nullability of the _sharedInstance()_.<br><br>
2. We can now query the user variable to easily access the _userId_, among the other variables the _ABKUser_ object is responsible for (firstName, lastName, phone, homeCity, etc.)<br><br>
3. In order to set the user, _changeUser()_ must be called with a corresponding _userId_.

{% endtab %}
{% endtabs %}

#### Checkpoint #5
Proceed to compile your code and run your application.

Try identifying users from a successful sign in/sign up/ be sure you have a solid understanding of what is and what is not an appropriate user identifier. 

In your dashboard, observe that the user identifier is logged before advancing any further. 

### Log Analytics

The next step is to enable your production code to log crucial analytics metrics to Braze without the need for countless _import Appboy-iOS-SDK_ statements. 

Without an _import Appboy-iOS-SDK_ statement, the production code should call into the _BrazeManager_ to log all analytics. 

This step is optional, but creating an extension for your analytics code in your _Brazemanager.swift_ file reads in a more organized manner as to what purpose is being served in the helper file, like so:

```swift
//MARK: -Analytics
extensions BrazeManager {

}
```

{% tabs %}
{% tab File? %}

Create a method that matches the Braze SDK's _logCustomEvent_ method: 
```swift
open func logCustomEvent(_ eventName: String, withProperties properties: [AnyHashable : Any]?)
```

```swift
func logCustomEvent(_ eventName: String, withProperties properties: [AnyHashable: Any]? = nil){
  //1 
  Appboy.sharedInstance()?.logCustomEvent(eventName, withProperties: properties)
}
```

This is by design because only the _BrazeManager.swift_ file can directly access the Braze iOS SDK methods. By creating a matching method, the result is the exact same and is done without the need for any direct dependencies on the Braze iOS SDK in your production code.

1. Custom events are logged from the Appboy object. In the method you just added, add the following line inside the method to log the custom event to Braze. _Properties_ is an optional parameter with a default value of nil. Custom events are not required to have properties but are required to have a name. 

{% endtab %}
{% endtabs %}


The SDK can log numerous types as custom attributes. There is no need to create helper methods for each value type that can be set. Only expose one method that can filter down to the appropriate value.

```swift
- (BOOL)setCustomAttributeWithKey:(NSString *)key andBOOLValue:(BOOL)value; 
- (BOOL)setCustomAttributeWithKey:(NSString *)key andIntegerValue:(NSIntenger)value; 
- (BOOL)setCustomAttributeWithKey:(NSString *)key andDoubleValue:(double)value; 
- (BOOL)setCustomAttributeWithKey:(NSString *)key andStringValue:(NSString *)value; 
- (BOOL)setCustomAttributeWithKey:(NSString *)key andDateValue:(NSDate *)value;
```

Create __one method__ that can encompass all of the available types that can be set for an
attribute. Add this method in your _BrazeManager.swift_ file in the analytics extension.

```swift
func setCustomAttributeWithKey<T: Equatable>(_ key: String?, andValue value: T?) {

}
```

The parameter value is a generic type that conforms to the _Equatable_ protocol. This is explicitly done, so if the type is not what the Braze iOS SDK expects, there will be a compile-time error. 

The parameters _key_ and _value_ are optional parameters that will be conditionally unwrapped in the method. This is just one way to ensure non-nil values are being passed to the Braze iOS SDK.

Custom attributes are logged from the ABKUser object. 

In the following, complete the method to filter through the various types. This code enumerates through the valid types and calls the method associated with the matching type. 

```swift
func setCustomAttributeWithKey<T: Equatable>(_ key: String?, andValue value: T?) {
  guard let key = key, let value = value else { return }
  switch value.self {
  case let value as Date:
    user?.setCustomAttributeWithKey(key, andDateValue: value)
  case let value as Bool:
    user?.setCustomAttributeWithKey(key, andBOOLValue: value)
  case let value as String:
    user?.setCustomAttributeWithKey(key, andStringValue: value)
  case let value as Double:
    user?.setCustomAttributeWithKey(key, andDoubleValue: value)
  case let value as Int:
    user?.setCustomAttributeWithKey(key, andIntegerValue: value)
  default:
   return
  }
}
```

Create a method that matches the Braze SDK's _logPurchase_ method: 
```swift
open func logPurchase(_ productIdentifier: String, inCurrency currency: String, atPrice price: NSDecimalNumber, withoutQuantity quantity: UInt)
```

{% tabs %}
{% tab NAME? %}

```swift
func logPurchase(_ productIdentifier: String, inCurrency currency: String, atPrice price:
String, withQuantity quantity: Int) {
  1 //
  Appboy.sharedInstance()?.logPurchase(productIdentifier, inCurrency: currency, atPrice: NSDecimalNumber(string: price), withQuantity: UInt(quantity))

}
```

This is by design because only the _BrazeManager.swift_ file can directly access the Braze iOS SDK methods. By Creating a matching method, the result is exactly the same and is done without the need for any direct dependencies on the Braze iOS SDK in your production code. 

1. Purchases are logged from the Appboy object. In the method you just added, add the following line inside that method to log purchases to Braze. The SDK has multiple methods for logging purchases, and this is just one example. The method also handles creating the _NSDecimal_ and _UInt_ object. How you want to handle that part is up to you, provided is just one example.

{% endtab %}
{% endtabs %}

#### Checkpoint 6
Proceed to compile your code and run your application. 
Try logging custom events. 
In your dashboard, observe that the custom events are logged before advancing any further. 

### In-App Messages
The next step is to enable your _BrazeManager.swift_ file code to conform to the _ABKInAppMessageUIDelegate_ to be able to handle the associated methods directly. 

The code for conforming to the delegate will be added in the _didFinishLaunching..._ methods in the _BrazeManager.swift_ file. Your initialization code should currently look like this:

{% tabs %}
{% tab BrazeManager.swift %}
```swift
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) {
  Appboy.start(withApiKey: apiKey, in: application, withLaunchOptions: launchOptions, withAppboyOptions: appboyOptions)

  let options: UNAuthorizationOptions = [.alert, .sound, .badge]
  UNUserNotificationCenter.current().requestAuthorization(options: options) { (granted, error) in
    Appboy.sharedInstance()?.pushAuthorization(fromUserNotificationCenter: granted)
  }
  UIApplication.shared.registerForRemoteNotifications()

  1 //
  Appboy.sharedInstance()?.inAppMessageController.inAppMessageUIController?.setInAppMessageUIDelegate?(self)
}
```
1. In the _BrazeManager.swift_ file, below the line of code that registers for remote notifications, add the following line of code in the _didFinishLaunching..._ method.

{% endtab %}
{% endtabs %}

Now that the _BrazeManager_ object is set as the delegate, process to create an extension that conforms to the ABKInAppMessageUIDelegate.

Add this snippet below the analytics section. This will be where the _BrazeManager.swift_ file handles all the _ABKInAppMessageUIDelegate_ methods. 

{% tabs %}
{% tab BrazeManager.swift %}
```swift
// Mark: - ABKInAppMessage UI Delegate
extension AppboyManager: ABKInAppMessageUIDelegate{
  //1 
  func inAppMessageViewControllerWith(_ inAppMessage: ABKInAppMessage) -> ABKInAppMessageViewController {
    switch inAppMessage {
    case is ABKInAppMessageSlideup:
      return ABKInAppMessageSlideupViewController(inAppMessage: inAppMessage)
    case is ABKInAppMessageModal:
      return ABKInAppMessageModalViewController(inAppMessage: inAppMessage)
    case is ABKInAppMessageFull:
      return ABKInAppMessageFullViewController(inAppMessage: inAppMessage)
    case is ABKInAppMessageHTML:
      return ABKInAppMessageHTMLViewController(inAppMessage: inAppMessage)
    default:
      return ABKInAppMessageViewController(inAppMessage: inAppMessage)
}
```
1.  Note that the _BrazeManager.swift_ object is set as the delegate. This will be there the _BrazeManager.swift_ file handles all of the _ABKInAppMessageUIDelegate_ methods. The _ABKInAppMessageUIDelegate_ does not come with any required methods, but listed above is an example of one.

{% endtab %}
{% endtabs %}

#### Checkpoint 7
Proceed to compile your code and run your application. 

Try sending yourself an in-app message. 

In the _Brazemanager.swift_ file, set a breakpoint at the entry of the example _ABKInAppMessageUIDelegate_ method. Send yourself an in-app message and confirm the breakpoint is hit before advancing any further. 

### Content Cards Extension

The next step is to enable your production code to display the Content Cards view controller without the need for countless _import Appboy-iOS-SDK_ statements. 

This step is optional, but creating an extension for your Content Cards code in your _BrazeManager.swfit_ file reads in a more organized manner as to what purpose is being served in the helper file, like so:

{% tabs %}
{% tab BrazeManager.swift %}
```swift
// MARK: - Content Cards
extension Brazemanager {
  1//
  func displayContentCards(navigationController: UINavigationController?){
      2//
      let contentCardsVc = ABKContentCardsTableViewController()
      contentCardsVs.title = "Content Cards"
      navigationController?.pushViewController(contentCardsVc, animated: true)
  }
}
```

1. Add the following method in your extension to display the _ABKContentCardsTableViewController_. An optional _navigationController_ is the only parameter needed to present or push Braze's view controller.<br><br>
2. Add the following lines of code in the method you just created. <br>The first line initializes an _ABKContentCardsTableViewController_ object. <br>The second line is an example of how to change the title, which will be reflected in the navigation bar. <br>The third line adds the initialized view controller to the navigation stack. 

{% endtab %}
{% endtabs %}

#### Checkpoint #8

Proceed to compile your code and run your application.

Try displaying the _ABKContentCardsTableViewController_ in your application. 
